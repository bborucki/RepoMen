Mon Jan 28 18:23:01 EST 2013
Attendees: Chris, Brian Drew
Questions: 

Decisions: 

Todo: 

Comments/Notes:

Meeting 1 (Mon Jan 28): Got part 3, 4, and 5 Compiled and Working. Agreed
to meet again Wednesday Jan 30 to finish part 6, including chapters to
read. 

Drew - upon running the make file in server we recieved an error about the architecture of the system, but the file seemed to make.

-----------------------------------------------

Wed Jan 30 17:32:46 EST 2013
Attendees: Chris, Brian, Drew
Questions: 

Decisions: 

Todo: None

Comments/Notes:

Meeting 2 (Wed Jan 30): Got client.c and server.c working for
part6. Created a1-done branch for submission 

Explanation of getInput:
Takes input from the user, and places it in the globals struct.  It does
this by first zeroing the buffer (in.data and in.newline), and then reads
from stdin into in.data, returning a pointer to the the input string. If
no input, len = 0, else len = length of the input string. It then removes 
a newline character if present and sets in.newline = 1. Finally it returns
the length of the input.

Explanation of sendStr:
Takes a pointer to a string and writes first the length of the string and 
then the string itself to the server's file descriptor, effectively
sending it to the server.  The function then creates a buffer and reads 
the file descriptor into it, checking for length. If the length read into
the buffer is not the same as that of what was written to the file
descriptor, return -1, else write the buffer to stdout.

Explanation of pthread_create:
Server idles in infinite loop until a client connects to the server, at
which time the server creates a unique pthread for the client that
joined. The pthread gives the client the illusion that the client is
working one on one with the server, even though the server is possibly managing
several different clients at the same time. 

--------------------------------------------
Sat Feb 16 18:16:12 EST 2013
Attendees: Chris, Brian, Drew
Questions: 

Decisions: When working together, use one comp/one large display

Todo: Begin implementation of NYI

Comments/Notes:

Began discussing the project, sat up further times to meet and decided to
use a different set up while working together -a computer hooked up to a
large display.  We imported the new code into our repo and replaced all
cases of "ADD CODE" with "NYI" and wrote a macro, placed in protocol.h,
which will allow us to trace the execution and implement the necessary
functions.

--------------------------------------------
Sat Apr 27
    -Brian

1:00 pm
Implemented move rpc functionality.  In the mean time I've commented out
the update portion server side while handling moves, because it was causing
the client to hang (the handler isn't fully implemented for this purpose
yet). So right now a player can connect, and issue move RPC's, which go to
the server, are checked for validity, and the client changes its own state
based off of the move_rep(ly) message from the server.  Along the way I
also implemented dump_player, dump_team, and verbose methods like that to
make debugging and printed output easier to handle/read.  Hopefully once
the back end is all set, implementing the GUI shouldn't take too long.

I'm going to start work on the update channel, and figuring out if we want
the player making the move to update it's view of the world (including it's
own position) with the info in the move_reply or the update from the
server. Then I'll start looking at what happens when multiple players join
and attempt to move.

2:00 pm
Working on the event channel.  The server now send out a quit event telling
its clients that its quitting for more graceful disconnect events, but
still needs to be implemented client side, as does the move update.  May
also want to consider drop/pickup/win updates as well.  Trying to clean up
clutter in the code for readability.
